#### ArrayList和List的区别：

1、ArrayList可以插入不同类型的数据，因为他会把插入的数据都当做object类型来处理。而List则是需要提前声明数据类型。

2、ArrayList不是安全的，因为类型是不确定，所以可能会存在类型不匹配的状况。而List因为是已经提前声明过的，自然比ArrayList要好。

3、ArrayList需要进行装箱和拆箱操作，会产生性能上的损耗。

 

#### 装箱和拆箱：

- 装箱是指将值类型打包到引用类型。

- 拆箱是将引用类型中的值类型提取出来。

都比较损耗性能。

 

#### Dictionary的实现原理：

有一个bunkets数组分散数据、一个entries数组存放entry数据，entry是一个结构体，四个属性：hashCode、next、key、value

根据key值存放到对应的索引的那一个entries中，插入的数据是插入到第一个元素的前面，next指向之前的第一个元素。

 

Gc，垃圾回收，产生的一些垃圾进行管理。有些引用类型的在使用之后不再被使用的情况下，可以自动回收释放内存，但是有些引用类型不会被自动回收，这是就需要自己编写释放内存。

常用算法：
1、引用计数法：每个对象加一个计数器，计数来表示所有该对象的引用数量，如果是0的话，表示没有引用，此时就删除这个对象。
2、标记清除法：分为标记和清楚，标记是记录所有根节点能到达的子节点，清除就是清理那些无法到达的引用类型，表示没有直接指向这个对象的引用，所以清除。
3、节点复制算法：和标记一样但是这次是把根节点能到达的对象赋值到新的内存中，不能到达的则不处理，到时候垃圾回收，就直接释放原来的存储区域接着维护新的存储区域即可。

 如何避免产生过多的垃圾：
1）减少用new创建对象的次数，在创建对象时会产生内存碎片，这样会造成碎片内存不法使用
2）使用公用的对象（静态成员，常量）。
3）在拼接大量字符串时StringBuilder。在使用注意，创建StringBuilder对象时要设置StringBuilder的初始大小如：
StringBuilder sbHtml = new StringBuilder (size);
4）使用object pool(对象池)

#### 委托：

- 顾名思义就是一种中介，通过委托可以存储多个有相同返回值和参数的方法。可以通过委托对象，来调用这些方法。

#### 事件

- 基本上说是一个用户操作。和委托一起使用。有发布器和订阅器。
发布器中主要是新建委托和基于委托创建。
订阅器用于接收事件并且提供事件处理程序的对象。
创建发布器和订阅器，将事件在订阅器中进行注册。就可以通过订阅器来接收事件从而给出处理。

#### 虚函数
1) 只需要在虚函数的声明处加上 virtual 关键字，函数定义处可以加也可以不加。

2) 为了方便，你可以只将基类中的函数声明为虚函数，这样所有派生类中具有遮蔽（覆盖）关系的同名函数都将自动成为虚函数。

3) 当在基类中定义了虚函数时，如果派生类没有定义新的函数来遮蔽此函数，那么将使用基类的虚函数。

4) 只有派生类的虚函数遮蔽基类的虚函数（函数原型相同）才能构成多态（通过基类指针访问派生类函数）。 

5) 构造函数不能是虚函数。对于基类的构造函数，它仅仅是在派生类构造函数中被调用，这种机制不同于继承。

6) 析构函数可以声明为虚函数，而且有时候必须要声明为虚函数。

#### 栈和堆的区别
栈：是由编译器在需要时自动分配，不需要时自动清除的变量存储区。通常存放局部变量、函数参数等。
堆：是由new分配的内存块，由程序员释放（编译器不管），一般一个new与一个delete对应，一个new[]与一个delete[]对应。如果程序员没有释放掉，资源将由操作系统在程序结束后自动回收。

#### 三次握手
第一次：客户端向服务端发送tcp报文，请求和服务端建立连接。（有客户端初始序列号为j）
第二次：服务器向客户端返回tcp报文，确认收到客户端的请求并给出回应。（有ack字段为j+1表示收到了序列号为j的报文，以及服务器的初始序列号k）
第三次：客户端响应给服务器一个tcp报文，来确立连接。（有ack为k+1）

#### 切线空间
TBN空间，切线、副法线、法线。法线是确定朝着z轴正方向，而切线和副法线则是垂直于法线计算得到。

#### 法线纹理
在模型空间下是五颜六色的
在切线空间下是蓝色的