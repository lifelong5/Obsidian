## 命令模式：
将命令封装，与目标行为解耦，使得命令由流程概念变为对象数据。也就是通过实例化命令，再去调用目标行为。
**好处：**

 - 通过命令数据队列等，可以轻易实现撤销，重做，时光倒流。
 - 可以形成日志，用于复现用户的行为。
 - 命令数据可以发送给不同的目标，可以形成不同的动作。

**缺点：**
可能会造成大量的实例化，浪费内存。

## 享元模式
不同的实例之间共享相同的特性，同时保留自己特性的部分。

**好处：**

可以一定程度上的节约时间和空间

## 观察者模式
事件与行为之间的解耦，将具体的行为提炼出来，而对于这一类的行为，反应者只需要观察这类行为是否存在即可。

## 原型模型
将一个或者多个对象当作原型，在此基础上进行复制多个对象，通过对于复制的对象进行修改配置得到新的对象。
## 单例模型
意味着这个对象只有一个实例，可以向全局提供。例如U3D中利用MonoBehaviour初始化单例非常简单，只要在Awake中加入Instance = this，不过要注意的是，别的类不能在Awake里使用这个单例。
## 状态模式
现在的状态和条件决定对象的新状态。
## 序列模式
包含了

 - 双缓冲模式
当一个缓冲准备好后才会被使用——就像一个集装箱装满才会发货一样；当一个缓冲被使用时另一个处于准备状态，就形成了双缓冲。在渲染中广泛使用，一帧准备好后才会被渲染到屏幕上——所以准备时间太长就会导致帧率下降
 - 游戏循环:可参考脚本生命周期
 - 更新方法:实际上是Unity通过反射在生命周期不同时刻调用MonoBehaviour中的相关方法

## 行为模式

 - 字节码：享元模式、原型模式中，不同的属性被存储在数据库中，而字节码是将行为存在数据库中
可用于实现可视化脚本编辑工具
 - 子类沙箱
子类使用基类方法，或在基类方法上扩展
 - 类型对象
其实是享元模式、原型模式的一种应用，以不同数据（而不是不同类）区分对象类型