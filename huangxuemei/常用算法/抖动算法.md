### 抖动介绍：

#### 作用：

 对于可用颜色较少的系统，可以以牺牲分辨率为代价，通过颜色值的抖动来增加可用颜色数量。

#### 图案法表示灰度：

用一定比例的黑白点组成的区域来表示灰度。

##### 例如：2*2的图案可以表示五种不同的灰度：

![image-20220929202408961](C:\Users\huangxuemei\AppData\Roaming\Typora\typora-user-images\image-20220929202408961.png)

如果想要表达256级的灰度的话，需要存储256个16*16的图案来，开销比较大。

#### 存储灰度图优化方法：

存储一个整数的矩阵，称为标准图案，其中每个值从0-255。

![image-20220929202931786](C:\Users\huangxuemei\AppData\Roaming\Typora\typora-user-images\image-20220929202931786.png)

如果想要得到某一级灰度图的话，先用灰度值与矩阵中的标准值进行比较，如果灰度值小于标准值，对应的灰度图的该像素内就为黑点，反之则不是。因为标准矩阵的各个数值都是连续的，所以灰度值增加，灰度图就会少一个黑点，也就可以通过一个矩阵来生成各个级别的灰度图了，而不需要提前存储，用一个16*16的矩阵就可以存储257种灰度图，256的时候是全白，1的时候是全黑。

#### 标准矩阵的生成：

设M1为：![image-20220929203850511](C:\Users\huangxuemei\AppData\Roaming\Typora\typora-user-images\image-20220929203850511.png)

则M2为：![image-20220929204000597](C:\Users\huangxuemei\AppData\Roaming\Typora\typora-user-images\image-20220929204000597.png)

M（n+1）为：![image-20220929204019406](C:\Users\huangxuemei\AppData\Roaming\Typora\typora-user-images\image-20220929204019406.png)

**M3是一个8*8的矩阵，是一个特殊的矩阵，称为Bayer抖动表，M4是一个16 * 16的矩阵。**

#### 图像的灰度表示：

如果使用灰度图来表示一张图像的灰度信息，如果标准矩阵是M3的话，原本N*N的图像就需要变成8N * 8N的图像来存储，这肯定不符合我们的需求。所以我们利用标准矩阵与实际图像的灰度值进行比较，得到该点是黑点还是白点，从而将图像表现为一张灰度图像。

```c++
if((g[x][y]>>2)>M[x%7][y%7]){
    //这个点为白点，其实就是获取这个像素的灰度值，如果该点的灰度值大于标准值，则为一个白点
}else{
    //这是个黑点
}
```

#### 图像表示灰度的图案表示的灰度级数不足想要的灰度要求

1、减小灰度图的尺寸，使得灰度图能表达更多的灰度级

2、降低要求

##### 3、图像抖动

- 标准抖动：前面提到的表示图像灰度图的方法，缺点是有规律，图案化时明显，并且由于比较时候的结果只有黑白两种输出，体现不出偏向于黑白的趋向。

- 随机抖动：

  - Floyd-Steinberg算法：

    将误差传播到邻近的象素，**其实就是在误差比较大的点的周围，根据误差值去影响周围的点的颜色输出，如果是一个偏黑色的一个点被打成了白色，那么误差值就会很大，会影响到周围的点去尽量输出黑点，从而使得最终得到一个灰色的效果，而对于误差比较小的点，小的误差对周围的影响很小，所以也就不会影响到周围的点。**

  ```c++
  b=0;//全黑
  w=255;//全白
  t=(b+2)/2=127.5;//中间值
  e;//误差
  g;//某个点的灰度值
  if(g>t){
      //为白点，
      e=g-255;//该灰度到全白的误差
      右边的像素+=3/8 * e;
      下边的像素+=3/8 * e;
      右下方的像素+=1/4 * e;
  }else{
      //为黑点
      e=g-b;//该灰度到全黑的误差
      右边的像素+=3/8 * e;
      下边的像素+=3/8 * e;
      右下方的像素+=1/4 * e;
  }
  ```

  以256级灰度为例，假设一个点的灰度为130，在灰度图中应该是一个灰点。由于一般图象中灰度是连续变化的，相邻象素的灰度值很可能与本象素非常接近，所以该点及周围应该是一片灰色区域。**在新图中，130大于128，所以打了白点，但130离真正的白点255还差的比较远，误差e=130-255=-125比较大。将3/8×(-125)加到相邻象素后，使得相邻象素的值接近0而打黑点。下一次，e又变成正的，使得相邻象素的相邻象素打白点，这样一白一黑一白，表现出来刚好就是灰色。**如果不传递误差，就是一片白色了。再举个例子，如果一个点的灰度为250，在灰度图中应该是一个白点，该点及周围应该是一片白色区域。在新图中，虽然e=-5也是负的，但其值很小，对相邻象素的影响不大，所以还是能够打出一片白色区域来。

### 有序抖动：

#### 标准矩阵的计算：

- 提前计算好映射矩阵：

![image-20220930163601046](C:\Users\huangxuemei\AppData\Roaming\Typora\typora-user-images\image-20220930163601046.png)

- 根据函数进行计算：

  ![image-20220930163809709](C:\Users\huangxuemei\AppData\Roaming\Typora\typora-user-images\image-20220930163809709.png)

  ```c++
  M(i,j)=biit_reverse(bit_interleave(bitwise_xor(i,j),i))/n^2;
  ```

  

- **预先计算的阙值映射：**存储的不是整数而是float类型。

  ![image-20220930164309841](C:\Users\huangxuemei\AppData\Roaming\Typora\typora-user-images\image-20220930164309841.png)

```c++
Mpre(i,j) = (Mint(i,j)+1) / n^2-0.5;//减去0.5是为了使得阙值归一化，使得其平均化为0
```

#### 算法：

##### 作用：

有序抖动算法正常呈现图像，但对于每个像素，**它根据其位置将其颜色值与阈值映射中的相应值偏移，从而导致像素的值在超过阈值时被量化为不同的颜色。**

```c++
c′=nearest_palette_color(c+r*(M(x mod n,y mode n)-1/2));//其中 M（i， j） 是第 i 行和第 j 列上的阈值映射，c′ 是变换后的颜色，r 是颜色空间中的散布量。假设RGB调色板具有23N均匀距离的颜色，其中每种颜色（红色，绿色和蓝色值的三重）由从0到255的八位字节表示，通常会选择r~255/n,（1⁄2 再次是归一化项)。
```

![image-20220930165737036](C:\Users\huangxuemei\AppData\Roaming\Typora\typora-user-images\image-20220930165737036.png)
